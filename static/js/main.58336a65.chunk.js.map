{"version":3,"sources":["AppContext.js","SpotifyCredientials.js","Login/Login.js","Home/Home.js","App.js","serviceWorker.js","index.js"],"names":["AppContext","createContext","APP_STATE_VALUES","ACCESS_TOKEN","key","type","ME","AppProvider","children","Provider","value","getPersistedState","state","item","localStorage","getItem","JSON","parse","clear","setPersistedState","setValue","setItem","stringify","redirectUri","process","REACT_APP_STAGE","scopes","hash","window","location","substring","split","reduce","initial","parts","decodeURIComponent","Login","useContext","useState","gettingToken","setGettingToken","redirect","setRedirect","useEffect","_token","access_token","to","className","Spinner","animation","role","href","join","onClick","Button","variant","Home","shouldReroute","setShouldReroute","isLoading","didLoad","dailyDriveState","setDailyDriveState","localMe","setLocalMe","accessToken","spotifyApiInstance","axios","create","baseURL","headers","Authorization","getMe","a","get","data","persistedMe","removePodcastsFromDD","dailyDriveTrackList","tracks","items","length","forEach","playlistItem","name","existingPlaylistId","id","trackUris","acc","trackItem","idx","track","push","uri","replaceItemsInPlaylist","post","public","collaborative","addItemsToPlaylist","error","uris","put","style","padding","minHeight","display","flexDirection","justifyContent","App","basename","path","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"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","file":"static/js/main.58336a65.chunk.js","sourcesContent":["import React, { createContext } from 'react'\n\nexport const AppContext = createContext({})\n\nexport const APP_STATE_VALUES = {\n  ACCESS_TOKEN: {\n    key: 'accessToken',\n    type: 'string',\n  },\n  ME: {\n    key: 'me',\n    type: 'object',\n  },\n}\n\nexport const AppProvider = ({ children }) => {\n  const setPersistedState = (state, setValue) => {\n    if (state.type === 'object') {\n      localStorage.setItem(state.key, JSON.stringify(setValue))  \n    } else {\n      localStorage.setItem(state.key, setValue)\n    }\n  }\n\n  const getPersistedState = (state) => {\n    try {\n      if (state.type === 'object') {\n        const item = localStorage.getItem(state.key)\n        if (item) return JSON.parse(item)\n        return null\n      } else {\n        return localStorage.getItem(state.key)\n      }\n    } catch {\n      localStorage.clear()\n    }\n  }\n\n  return (\n    <AppContext.Provider value={{\n      APP_STATE_VALUES,\n      getPersistedState,\n      setPersistedState,\n    }}>\n      {children}\n    </AppContext.Provider>\n  )\n}\n","const redirectUri = process.env.REACT_APP_STAGE === 'dev' ? 'localhost:3000' : 'http://matthewfbenjamin.github.io/react-spotify' // https://serverless-stack.com/chapters/environments-in-create-react-app.html\nconst clientId = '7719deb8aec14035bd2d6d603b240f78'\nconst clientSecret = '6773e4e378fa4a1b87e3e8c4f8c85da4'\n\nconst scopes = ['user-read-private', 'user-read-email', 'playlist-read-collaborative', 'playlist-modify-public', 'playlist-read-private', 'playlist-modify-private']\n\n// Get the hash of the url\nconst hash = window.location.hash\n  .substring(1)\n  .split(\"&\")\n  .reduce(function (initial, item) {\n    if (item) {\n      var parts = item.split(\"=\");\n      initial[parts[0]] = decodeURIComponent(parts[1]);\n    }\n    return initial;\n  }, {})\n\nconst YOUR_DAILY_DRIVE_ID = '37i9dQZF1EfMJO4KCTeoFL'\nconst DAILY_DRIVE_OVERWRITE_NAME = 'Daily Drive (No Podcasts)'\n\nexport {\n  redirectUri,\n  clientId,\n  clientSecret,\n  scopes,\n  hash,\n  YOUR_DAILY_DRIVE_ID,\n  DAILY_DRIVE_OVERWRITE_NAME,\n}","import React, { useState, useEffect, useContext } from 'react'\nimport Spinner from 'react-bootstrap/Spinner'\nimport Button from 'react-bootstrap/Button'\nimport { Redirect } from 'react-router-dom'\n\nimport { AppContext } from '../AppContext'\nimport { clientId, redirectUri, scopes, hash } from '../SpotifyCredientials'\n\nexport const AUTH_ENDPOINT = 'https://accounts.spotify.com/authorize'\n\nconst Login = () => {\n  const { APP_STATE_VALUES: { ACCESS_TOKEN }, setPersistedState } = useContext(AppContext)\n  const [gettingToken, setGettingToken] = useState(false)\n  const [redirect, setRedirect] = useState(false)\n  \n  useEffect(() => {\n    const _token = hash.access_token\n    if (_token) {\n      setPersistedState(ACCESS_TOKEN, _token)\n      setRedirect(true)\n    }\n  }, [setPersistedState, ACCESS_TOKEN])\n\n  if (redirect) return <Redirect to=\"/home\" />\n  return (\n    <div className=\"App\">\n      <header className=\"App-header\">\n        {!gettingToken ? (\n          <a\n            className=\"btn btn--loginApp-link\"\n            href={`${AUTH_ENDPOINT}?client_id=${clientId}&redirect_uri=${redirectUri}&scope=${scopes.join(\n              \"%20\"\n            )}&response_type=token&show_dialog=true`}\n            onClick={() => setGettingToken(true)}\n          >\n            <Button variant=\"success\">\n              Login to Spotify\n            </Button>\n          </a>\n        ) : <Spinner animation=\"border\" role=\"status\" />}\n      </header>\n    </div>\n  )\n}\n\nexport default Login","import React, { useContext, useEffect, useState } from 'react'\nimport { Redirect } from 'react-router-dom'\nimport axios from 'axios'\nimport Button from 'react-bootstrap/Button'\n\nimport { AppContext } from '../AppContext'\nimport { YOUR_DAILY_DRIVE_ID, DAILY_DRIVE_OVERWRITE_NAME } from '../SpotifyCredientials'\n\nconst Home = () => {\n  const { APP_STATE_VALUES: { ACCESS_TOKEN, ME }, getPersistedState, setPersistedState } = useContext(AppContext)\n  const [shouldReroute, setShouldReroute] = useState(false)\n  // const [playlistState, setPlaylistState] = useState({ isLoading: false, didLoad: false, playlists: [] })\n  const [dailyDriveState, setDailyDriveState] = useState({ isLoading: false, didLoad: false })\n  const [localMe, setLocalMe] = useState(null)\n  const accessToken = getPersistedState(ACCESS_TOKEN)\n\n  const spotifyApiInstance = axios.create({\n    baseURL: 'https://api.spotify.com/v1',\n    headers: { Authorization: `Bearer ${accessToken}` }\n  });\n\n  useEffect(() => {\n    const getMe = async () => {\n      try {\n        const { data } = await spotifyApiInstance.get('/me')\n        setPersistedState(ME, data)\n        setLocalMe(data)\n      } catch (error) {\n        setShouldReroute(true)\n      }\n    }\n\n    const persistedMe = getPersistedState(ME)\n    if (!persistedMe) getMe()\n    else setLocalMe(persistedMe)\n  }, [ME, accessToken, getPersistedState, setPersistedState, spotifyApiInstance])\n\n  const removePodcastsFromDD = async () => {\n    try {\n      setDailyDriveState({ ...dailyDriveState, isLoading: true })\n      // GET THE USER'S DAILY DRIVE (Only works for me, now)\n      // TODO: Update for everyone\n      const dailyDriveTrackList = await spotifyApiInstance.get(`/playlists/${YOUR_DAILY_DRIVE_ID}`)\n      if (\n        dailyDriveTrackList.data &&\n        dailyDriveTrackList.data.tracks &&\n        dailyDriveTrackList.data.tracks.items &&\n        dailyDriveTrackList.data.tracks.items.length > 0 &&\n        localMe\n      ) {\n        // Get all the playlists and see if the DAILY_DRIVE_OVERWRITE_NAME exists already\n        const playlists = await spotifyApiInstance.get('/me/playlists')\n\n        let existingPlaylistId\n        playlists.data.items.forEach((playlistItem) => {\n          if (playlistItem.name === DAILY_DRIVE_OVERWRITE_NAME) existingPlaylistId = playlistItem.id\n        })\n\n        const trackUris = dailyDriveTrackList.data.tracks.items.reduce((acc, trackItem, idx) => {\n          if (idx >= 0 && trackItem.track.type === 'track') acc.push(trackItem.track.uri)\n          return acc\n        }, [])\n        \n        if (existingPlaylistId) {\n          // Replace items in the current playlist with the trackUris\n          await replaceItemsInPlaylist(existingPlaylistId, trackUris)\n        } else {\n          // Create a new playlist and add the track URI's\n          const { data } = await spotifyApiInstance.post(`/users/${localMe.id}/playlists`, {\n            name: DAILY_DRIVE_OVERWRITE_NAME,\n            public: false,\n            collaborative: false,\n          })\n          await addItemsToPlaylist(data.id, trackUris)\n        }\n      }\n    } catch (error) {\n      // TODO: Signout if access token no longer valid\n      // if (badAccessToken) setShouldReroute(true)\n      setDailyDriveState({ isLoading: false, didLoad: true, error })\n    }\n  }\n\n  const addItemsToPlaylist = async (existingPlaylistId, trackUris) => {\n    await spotifyApiInstance.post(`/playlists/${existingPlaylistId}/tracks`, {\n      uris: trackUris,\n    })\n  }\n\n  const replaceItemsInPlaylist = async (existingPlaylistId, trackUris) => {\n    await spotifyApiInstance.put(`/playlists/${existingPlaylistId}/tracks`, {\n      uris: trackUris,\n    })\n  }\n\n  if (!accessToken || shouldReroute) return <Redirect to=\"/login\" />\n\n  return (\n    <div style={{\n      padding: '30px',\n      minHeight: '100vh',\n      display: 'flex',\n      flexDirection: 'column',\n      justifyContent: 'space-between',\n    }}>\n      <div>\n        {localMe &&\n          <Button variant=\"success\" onClick={removePodcastsFromDD}>\n            Remove Podcasts from Daily Drive\n          </Button>\n        }\n      </div>\n      <div>\n        <Button variant=\"danger\" onClick={() => setShouldReroute(true)}>\n          Logout\n        </Button>\n      </div>\n    </div>\n  )\n}\n\nexport default Home\n","import React from 'react'\nimport { BrowserRouter, Switch, Route, Redirect } from 'react-router-dom'\n\nimport { AppProvider } from './AppContext'\nimport { Login } from './Login'\nimport { Home } from './Home'\nimport './App.css'\n\n\nconst App = () => {\n  return (\n    <AppProvider>\n      <BrowserRouter basename='/react-spotify'>\n        <Switch>\n          <Route path=\"/login\">\n            <Login />\n          </Route>\n          <Route path=\"/home\">\n            <Home />\n          </Route>\n\n          <Route path=\"/\">\n            <Redirect to=\"/login\" />\n          </Route>\n        </Switch>\n      </BrowserRouter>\n    </AppProvider>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nimport 'bootstrap/dist/css/bootstrap.min.css';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}